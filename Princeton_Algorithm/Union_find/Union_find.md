## Princeton- Algorithm
1st week：Union-Find
#### 问题描述
有N个元素，从0-N-1编号，假如两个元素之间的连接视为通路，当执行多次任意的两个元素之间的连接之后，如何判断两个元素能够经由已有路径相连通。对于连接的动作称为union，判断是否连接的操作称为find，如下图
![enter image description here](http://obpbs8a3y.bkt.clouddn.com/1.jpg)

从上图中可以看出，0, 1, 2, 5, 6, 7 中的任意两个元素都是相连的，同样 3, 4, 8, 9 中任意两个元素也是互连的，但是第一个集合和第二个集合的元素却是无法连通的。

实际操作中可用于在一个庞大的网路环境下，如何迅速判断某两个点是否相连，如下图：
![enter image description here](http://obpbs8a3y.bkt.clouddn.com/2.jpg)
####有效算法的开发步骤
1. 构建需求模型
2. 寻找所需算法
3. 方法的效率和内存的使用
4. 效率差或者内存占用率高，找出问题的原因
5. 寻找解决办法重复3

####首先确认Union和Find操作应该满足怎样的条件：
find操作：确认两个对象是否连接：
反射性：P连接到Q
对称性：P连接到Q，则 Q连接到P
传递性：P连接到Q，Q连接到R，则P也连接到R

union操作：连接在一起的对象，我们统称为一个连接集合，执行一次union操作就相当于将两个对象所在的集合连接到一起，组成一个新的集合。新集合中的任意两个成员也应该都处于连接状态。
